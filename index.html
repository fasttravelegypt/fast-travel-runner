<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fast Travel Running Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body {
    margin: 0;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    touch-action: manipulation;
    overflow: hidden;
}
canvas {
    background: #000;
    border: 2px solid #fff;
    display: block;
}
</style>
</head>

<body>
<canvas id="gameCanvas"></canvas>

<script>
/* =====================================================
   BASE SETTINGS & MOBILE SCALING
===================================================== */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let BASE_WIDTH = 360;
let BASE_HEIGHT = 640;
let DPR = Math.min(window.devicePixelRatio || 1, 2);

function resizeCanvas() {
    const scale = Math.min(window.innerWidth / BASE_WIDTH, window.innerHeight / BASE_HEIGHT);
    canvas.width = BASE_WIDTH * DPR;
    canvas.height = BASE_HEIGHT * DPR;
    canvas.style.width = BASE_WIDTH * scale + "px";
    canvas.style.height = BASE_HEIGHT * scale + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing to DPR
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

/* =====================================================
   GLOBAL ERROR CATCHER
===================================================== */
window.onerror = (msg, src, line) => { console.error(msg, line); return true; };

/* =====================================================
   CONSTANTS
===================================================== */
const GAME_SPEED = 4;
const GRAVITY = 0.7;
const JUMP_FORCE = -18;
const SECOND_JUMP_FORCE = -14;
const DEBUG_HITBOX = false;

const MAX_OBSTACLES_ON_SCREEN = 4;
const MAX_COLLECTABLES_ON_SCREEN = 2;

let speedMultiplier = 1;
const SPEED_INCREMENT = 0.0003;
const MAX_SPEED_MULTIPLIER = 3;

/* =====================================================
   AUDIO
===================================================== */
const jumpSound = new Audio("assets/jump.mp3");
const gameOverSound = new Audio("assets/gameover.mp3");
const collectSound = new Audio("assets/collect.mp3");
const obstacleScoreSound = new Audio("assets/score.mp3");
const bgmSound = new Audio("assets/bgm.mp3");
const runSound = new Audio("assets/run_sound.mp3");
bgmSound.loop = true; bgmSound.volume = 0.3;
runSound.loop = true; runSound.volume = 0.5;

function playSound(sound) { sound.cloneNode().play().catch(()=>{}); }

/* =====================================================
   HELPERS
===================================================== */
function safeDraw(img, x, y, w, h) {
    if (!img || !img.complete || img.naturalWidth === 0) return;
    ctx.drawImage(img, x, y, w, h);
}
function rectsOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}
function drawPlayerShadow(player) {
    const factor = Math.min(Math.abs(player.y - player.groundY) / 120, 1);
    const radius = 20 - factor * 10;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(player.x + player.width / 2, player.groundY + player.height - 10, radius, radius * 0.45, 0, 0, Math.PI*2);
    ctx.fill();
}

/* =====================================================
   ASSETS
===================================================== */
const background = new Image();
background.src = "assets/background.png";

const coinTypes = [
    { src: "assets/collectable/coin5.png", score: 5, weight: 50 },
    { src: "assets/collectable/coin10.png", score: 10, weight: 20 },
    { src: "assets/collectable/coin20.png", score: 20, weight: 15 },
    { src: "assets/collectable/coin50.png", score: 50, weight: 10 },
    { src: "assets/collectable/coin100.png", score: 100, weight: 5 }
];
coinTypes.forEach(c => { c.image = new Image(); c.image.src = c.src; });

function getRandomCoinType() {
    const total = coinTypes.reduce((s,c)=>s+c.weight,0);
    let r = Math.random()*total;
    for (const c of coinTypes) { if (r<c.weight) return c; r-=c.weight; }
    return coinTypes[0];
}

/* =====================================================
   PLAYER ANIMATIONS
===================================================== */
const runFrames = [], jumpFrames = [];
for(let i=1;i<=8;i++){let img=new Image();img.src=`assets/run/run_${i}.png`;runFrames.push(img);}
for(let i=1;i<=12;i++){let img=new Image();img.src=`assets/jump/jump_${i}.png`;jumpFrames.push(img);}

/* =====================================================
   PLAYER
===================================================== */
const player = { x:20, y:0, width:120, height:120, velocityY:0, state:"run", hitbox:{offsetX:60,offsetY:8,width:26,height:70}, jumpCount:0, maxJumps:2 };

/* =====================================================
   OBSTACLES
===================================================== */
const obstacleConfigs = [
    { src:"assets/obstacle/obstacle1.png", width:120,height:170,yOffset:-45,hitbox:{offsetX:0,offsetY:0,width:120,height:170} },
    { src:"assets/obstacle/obstacle2.png", width:100,height:100,yOffset:28,hitbox:{offsetX:0,offsetY:0,width:100,height:100} },
    { src:"assets/obstacle/obstacle3.png", width:230,height:150,yOffset:-10,hitbox:{offsetX:0,offsetY:40,width:230,height:110} },
    { src:"assets/obstacle/obstacle4.png", width:120,height:150,yOffset:-250,hitbox:{offsetX:0,offsetY:0,width:120,height:150} },
    { src:"assets/obstacle/obstacle6.png", width:220,height:150,yOffset:-250,hitbox:{offsetX:0,offsetY:0,width:220,height:150} },
];
obstacleConfigs.forEach(o=>{o.image=new Image();o.image.src=o.src;});

/* =====================================================
   GAME STATE
===================================================== */
let obstacles=[], collectables=[], backgroundX=0, score=0, gameOver=false, gameStarted=false, animationFrame=0, animationTimer=0;
let floatingTexts=[], floatingScores=[];
let nextObstacleTimer=0, nextCollectableTimer=120, lastObstacleIndex=-1;

/* =====================================================
   INPUT
===================================================== */
function handleInput() {
    if(!gameStarted){ gameStarted=true; bgmSound.play().catch(()=>{}); runSound.play().catch(()=>{}); player.groundY = canvas.height - 150; return; }
    if(gameOver) return restartGame();
    if(player.jumpCount<player.maxJumps){ 
        player.velocityY = player.jumpCount===0?JUMP_FORCE:SECOND_JUMP_FORCE;
        player.state="jump"; player.jumpCount++; jumpSound.currentTime=0; jumpSound.play(); runSound.pause();
    }
}
canvas.addEventListener("touchstart", handleInput);
document.addEventListener("keydown", e=>{ if(e.code==="Space") handleInput(); });

/* =====================================================
   SPAWN FUNCTIONS
===================================================== */
function spawnObstacle(){
    if(obstacles.length>=MAX_OBSTACLES_ON_SCREEN) return;
    let index; do{ index=Math.floor(Math.random()*obstacleConfigs.length);}while(index===lastObstacleIndex); lastObstacleIndex=index;
    const c=obstacleConfigs[index];
    obstacles.push({x:canvas.width+40, y:player.groundY+c.yOffset, width:c.width, height:c.height, image:c.image, hitbox:c.hitbox, passed:false});
    nextObstacleTimer=Math.floor(Math.random()*100)+80;
}
function spawnCollectable(){
    if(collectables.length>=MAX_COLLECTABLES_ON_SCREEN) return;
    const type=getRandomCoinType();
    const c={x:canvas.width+40, y:player.groundY-30-Math.random()*200, width:50,height:50,hitbox:{offsetX:0,offsetY:0,width:50,height:50}, type:type};
    for(const o of obstacles){ const oHit={x:o.x+o.hitbox.offsetX,y:o.y+o.hitbox.offsetY,w:o.hitbox.width,h:o.hitbox.height};
        const cHit={x:c.x+c.hitbox.offsetX,y:c.y+c.hitbox.offsetY,w:c.hitbox.width,h:c.hitbox.height};
        if(rectsOverlap(oHit,cHit)) return;
    }
    collectables.push(c);
    nextCollectableTimer=Math.floor(Math.random()*180)+120;
}

/* =====================================================
   RESTART
===================================================== */
function restartGame(){
    obstacles=[]; collectables=[]; floatingTexts=[]; floatingScores=[];
    score=0; gameOver=false; speedMultiplier=1;
    player.y=player.groundY; player.velocityY=0; player.jumpCount=0; player.state="run";
    runSound.play().catch(()=>{});
}

/* =====================================================
   UPDATE & DRAW
===================================================== */
let lastTime = 0;
function loop(timestamp){
    const deltaTime = (timestamp - lastTime)/16.666; // approx 60fps reference
    lastTime = timestamp;

    if(gameStarted && !gameOver){
        const speed = GAME_SPEED*speedMultiplier*deltaTime;
        speedMultiplier = Math.min(speedMultiplier+SPEED_INCREMENT*deltaTime, MAX_SPEED_MULTIPLIER);

        backgroundX -= speed;
        if(backgroundX<=-canvas.width) backgroundX=0;

        player.velocityY += GRAVITY*deltaTime;
        player.y += player.velocityY*deltaTime;
        if(player.y>=player.groundY){ player.y=player.groundY; player.velocityY=0; player.jumpCount=0; if(player.state!=="run"){player.state="run"; runSound.play().catch(()=>{});} }

        animationTimer += deltaTime;
        if(animationTimer>3){ animationTimer=0; animationFrame++; if(player.state==="run" && animationFrame>=runFrames.length) animationFrame=0; if(player.state==="jump" && animationFrame>=jumpFrames.length) animationFrame=jumpFrames.length-1; }

        if(nextObstacleTimer--<=0) spawnObstacle();
        if(nextCollectableTimer--<=0) spawnCollectable();

        obstacles.forEach(o=>o.x-=speed);
        collectables.forEach(c=>c.x-=speed);

        const pHit={x:player.x+player.hitbox.offsetX, y:player.y+player.hitbox.offsetY, w:player.hitbox.width, h:player.hitbox.height};
        obstacles.forEach(o=>{ const h=o.hitbox; const oHit={x:o.x+h.offsetX, y:o.y+h.offsetY, w:h.width, h:h.height}; if(rectsOverlap(pHit,oHit)){ gameOverSound.play(); gameOver=true; runSound.pause(); }
            if(!o.passed && o.x+o.width<player.x){ o.passed=true; score+=1; } // simplified scoring
        });

        collectables = collectables.filter(c=>{ const cHit={x:c.x+c.hitbox.offsetX,y:c.y+c.hitbox.offsetY,w:c.hitbox.width,h:c.hitbox.height}; if(rectsOverlap(pHit,cHit)){ score+=c.type.score; collectSound.play(); return false;} return c.x+c.width>0; });

        floatingTexts.forEach(ft=>{ ft.y-=1.2*deltaTime; ft.opacity-=0.02*deltaTime; });
        floatingTexts=floatingTexts.filter(ft=>ft.opacity>0);
        floatingScores.forEach(fs=>{ fs.y-=1.2*deltaTime; fs.opacity-=0.02*deltaTime; });
        floatingScores=floatingScores.filter(fs=>fs.opacity>0);

        obstacles=obstacles.filter(o=>o.x+o.width>0);
    }

    // DRAW
    ctx.clearRect(0,0,canvas.width,canvas.height);
    safeDraw(background,backgroundX,0,canvas.width,canvas.height);
    safeDraw(background,backgroundX+canvas.width,0,canvas.width,canvas.height);
    drawPlayerShadow(player);
    safeDraw(player.state==="run"?runFrames[animationFrame]:jumpFrames[animationFrame], player.x, player.y, player.width, player.height);
    obstacles.forEach(o=>safeDraw(o.image,o.x,o.y,o.width,o.height));
    collectables.forEach(c=>safeDraw(c.type.image,c.x,c.y,c.width,c.height));

    ctx.fillStyle="#fff"; ctx.font="18px Arial"; ctx.textAlign="left"; ctx.fillText("Score: "+score,10,30);
    if(!gameStarted){ ctx.textAlign="center"; ctx.font="26px Arial"; ctx.fillText("Fast Travel Running Game",canvas.width/2,canvas.height/2); ctx.font="18px Arial"; ctx.fillText("Tap to Start",canvas.width/2,canvas.height/2+30); }
    if(gameOver){ ctx.textAlign="center"; ctx.fillText("Game Over",canvas.width/2,canvas.height/2); ctx.fillText("Final Score: "+score,canvas.width/2,canvas.height/2+30); }

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
