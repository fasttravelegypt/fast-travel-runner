<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fast Travel Running Game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
body {
    margin: 0;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    touch-action: manipulation;
}
canvas {
    background: #000;
    border: 2px solid #fff;
}
</style>
</head>

<body>
<canvas id="gameCanvas" width="360" height="640"></canvas>

<script>
/* =====================================================
   GLOBAL ERROR CATCHER
===================================================== */
window.onerror = function (msg, src, line) {
    console.error("GLOBAL ERROR:", msg, "Line:", line);
    alert("Game error:\n" + msg);
    return true;
};

/* =====================================================
   CANVAS
===================================================== */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");


/* =====================================================
   CONSTANTS
===================================================== */
const GAME_SPEED = 5;
const GRAVITY = 0.7;
const JUMP_FORCE = -12;
const SECOND_JUMP_FORCE = -10;
const GROUND_Y = canvas.height -225;
const DEBUG_HITBOX = false;
const DISTANCE_SCORE_RATE = 0.01; // 1 score per 100 pixels (tune later)
const MAX_OBSTACLES_ON_SCREEN = 4;
const MAX_COLLECTABLES_ON_SCREEN = 2;
const FIXED_FPS = 60;
const FRAME_TIME = 1000 / FIXED_FPS;
const MAX_DELTA = 100; // ms, ~6 frames at 60 FPS

/* =====================================================
   SPEED INCREMENT
===================================================== */
let speedMultiplier = 1;
const SPEED_INCREMENT = 0.0003;
const MAX_SPEED_MULTIPLIER = 3;

/* =====================================================
   AUDIO
===================================================== */
const jumpSound = new Audio("assets/jump.mp3");
const gameOverSound = new Audio("assets/gameover.mp3");
const collectSound = new Audio("assets/collect.mp3");
const bgmSound = new Audio("assets/bgm.mp3");
const runSound = new Audio("assets/run_sound.mp3");
const scoreTickSound = new Audio("assets/tick.mp3");
scoreTickSound.volume = 0.5; // adjust as needed

/* ===== iOS SAFARI AUDIO FIX (STEP 4) ===== */
[jumpSound, gameOverSound, collectSound, bgmSound, runSound, scoreTickSound].forEach(a => {
    a.preload = "none";
});
/* ======================================== */


bgmSound.loop = true; bgmSound.volume = 0.3;
runSound.loop = true; runSound.volume = 0.5;

/* =====================================================
   HELPERS
===================================================== */
function safeDraw(img, x, y, w, h) {
    if (!img || !img.complete || img.naturalWidth === 0) return;
    ctx.drawImage(
    img,
    Math.round(x),
    Math.round(y),
    Math.round(w),
    Math.round(h)
);
}
function drawHitbox(x, y, w, h, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);
}
function rectsOverlap(a, b) {
    return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
    );
}
function drawPlayerShadow(player) {
    const groundY = GROUND_Y + player.height - 10;
    const factor = Math.min(Math.abs(player.y - GROUND_Y) / 120, 1);
    const radius = 12 - factor * 10;

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(player.x + player.width / 2, groundY, radius, radius * 0.45, 0, 0, Math.PI * 2);
    ctx.fill();
}

function spawnPlayerComboText(text) {
    const ft = floatingTextPool.pop() || {};
    ft.x = player.x + player.width / 2;
    ft.y = player.y - 10;
    ft.text = text;
    ft.opacity = 1;
    ft.speedY = 0.8;
    ft.followPlayer = true; // NEW FLAG
    floatingTexts.push(ft);
}

/* =====================================================
   ASSETS
===================================================== */
const background = new Image();
background.src = "assets/background.png";

/* =====================================================
   LOADING SYSTEM
===================================================== */
let assetsLoaded = 0;
let totalAssets = 0;
let assetsReady = false;

function registerAsset(asset) {
    totalAssets++;

    if (asset instanceof HTMLImageElement) {
        asset.onload = asset.onerror = asset.onabort = () => {
            assetsLoaded++;
            checkAssetsReady();
        };
    } else if (asset instanceof HTMLAudioElement) {
        asset.oncanplaythrough = () => {
            assetsLoaded++;
            checkAssetsReady();
        };
    }
}

function checkAssetsReady() {
    if (assetsLoaded >= totalAssets) {
        assetsReady = true;
    }
}
registerAsset(background);

/* =====================================================
   SINGLE COLLECTABLE
===================================================== */
const collectableImg = new Image();
collectableImg.src = "assets/collectable/coin.png"; // ONE asset only
registerAsset(collectableImg);

/* =====================================================
   PLAYER ANIMATION ARRAYS
===================================================== */
const runFrames = [];
const jumpFrames = [];

/* =====================================================
   PLAYER ANIMATION
===================================================== */
for (let i = 1; i <= 8; i++) {
    const img = new Image();
    img.src = `assets/run/run_${i}.png`;
    runFrames.push(img);
registerAsset(img);

}

for (let i = 1; i <= 12; i++) {
    const img = new Image();
    img.src = `assets/jump/jump_${i}.png`;
    jumpFrames.push(img);
registerAsset(img);

}
/* =====================================================
   PLAYER
===================================================== */
const player = {
    x: 10,
    y: GROUND_Y,
    width: 60,
    height: 60,
    velocityY: 0,
    state: "run",
    hitbox: { offsetX: 25, offsetY: 10, width: 20, height: 40 },
    jumpCount: 0,
    maxJumps: 2,
    isFalling: false,
    fallSpeed: 0,
};


/* =====================================================
   OBSTACLE CONFIGS
===================================================== */
const obstacleConfigs = [
    { 
        type: "fridge",
        width: Math.round(player.width * 0.7),
        height: Math.round(player.height * 1.3),
        yOffset: -(Math.round(player.height * 1.3) - player.height)
    },
    { 
        type: "table",
        width: Math.round(player.width * 1.4),
        height: Math.round(player.height * 0.6),
        yOffset: -(Math.round(player.height * 0.6) - player.height)
    },
    {
        type: "oven",
        width: Math.round(player.width * 0.8),
        height: Math.round(player.height * 0.9),
        yOffset: -(Math.round(player.height * 0.9) - player.height) // corrected
    },
{
    type: "shelf",
    width: Math.round(player.width * 1.6),
    height: Math.round(player.height * 0.7), // shelf body height
    yOffset: -(Math.round(player.height * 1.8) - player.height)
},
{
    type: "hole",
    width: Math.round(player.width * 1.1),
    height: Math.round(player.height * 0.35),
    yOffset: -(Math.round(player.height * .3) - player.height)
},
];

/* =====================================================
   FLOATING WORDS & SCORES
===================================================== */
const floatingWords = [
    { minSpeed: 0, words: ["Great", "Nice"] },
    { minSpeed: 1.5, words: ["Amazing", "Fantastic"] },
    { minSpeed: 2.5, words: ["Wonderful", "Unstoppable"] }
];
let floatingTexts = [];
let floatingScores = [];

/* =====================================================
   OBJECT POOLS (GC OPTIMIZATION)
===================================================== */
const floatingTextPool = [];
const floatingScorePool = [];


/* =====================================================
   GAME STATE
===================================================== */
let obstacles = [];
let collectables = [];
let backgroundX = 0;
let distanceScore = 0;
let coinScore = 0;
let totalCoinsCollected = 0; // NEW: raw coin count (for combo logic)
let gameOver = false;
let animationFrame = 0;
let animationTimer = 0;
let gameStarted = false;
let lastObstacleIndex = -1;
let lastTime = performance.now();
let lastFrameTime = performance.now();
let frameAccumulator = 0;
let distanceRun = 0;
let comboMultiplier = 1;
let nextComboAt = 10;
let totalScore = 0;
let displayDistance = 0;
let displayCoins = 0;
let displayTotal = 0;
let scoreAnimDone = false;


/* =====================================================
   REUSED HITBOX OBJECTS (GC OPTIMIZATION)
===================================================== */
const pHit = { x:0, y:0, w:0, h:0 };
const oHit = { x:0, y:0, w:0, h:0 };
const cHit = { x:0, y:0, w:0, h:0 };


/* =====================================================
   INPUT
===================================================== */
function handleInput() {
    if (!assetsReady) return;

    // FIRST USER INTERACTION â€” unlock audio
    if (!gameStarted) {
        gameStarted = true;

        // iOS-safe audio init
        [bgmSound, runSound, jumpSound, collectSound, gameOverSound, scoreTickSound].forEach(a => {
            a.load();
        });

        bgmSound.play().catch(()=>{});
        runSound.play().catch(()=>{});
        return;
    }

    if (gameOver) {
        if (scoreAnimDone) restartGame();
        return;
    }

    if (player.jumpCount < player.maxJumps) {
        player.velocityY = player.jumpCount === 0 ? JUMP_FORCE : SECOND_JUMP_FORCE;
        player.state = "jump";
        player.jumpCount++;
        jumpSound.currentTime = 0;
        jumpSound.play().catch(()=>{});
        runSound.pause();
    }
}

canvas.addEventListener("touchstart", handleInput);
document.addEventListener("keydown", e => e.code === "Space" && handleInput());

/* =====================================================
   SPAWN OBSTACLE
===================================================== */
let nextObstacleTimer = 0;
function spawnObstacle() {
    if (obstacles.length >= MAX_OBSTACLES_ON_SCREEN) return;

    const index = Math.floor(Math.random() * obstacleConfigs.length);
    const c = obstacleConfigs[index];

    obstacles.push({
        x: canvas.width + 40,
        y: GROUND_Y + c.yOffset,
        width: c.width,
        height: c.height,
        type: c.type,
        hitbox: { offsetX: 0, offsetY: 0, width: c.width, height: c.height },
        passed: false
    });

    nextObstacleTimer = Math.floor(Math.random() * 20) + 50;
}



/* =====================================================
   SPAWN COLLECTABLE
===================================================== */
let nextCollectableTimer = 120;
function spawnCollectable() {
    if (collectables.length >= MAX_COLLECTABLES_ON_SCREEN) return;

    const c = {
        x: canvas.width + 40,
        y: GROUND_Y + 10 - Math.random() * 80,
        width: 15,
        height: 25,
        image: collectableImg,
        hitbox: {
            offsetX: 8,
            offsetY: 8,
            width: 24,
            height: 24
        }
    };

    // Prevent overlap with obstacles
    for (const o of obstacles) {
        const h = o.hitbox;
        oHit.x = o.x + h.offsetX;
        oHit.y = o.y + h.offsetY;
        oHit.w = h.width;
        oHit.h = h.height;

        cHit.x = c.x + c.hitbox.offsetX;
        cHit.y = c.y + c.hitbox.offsetY;
        cHit.w = c.hitbox.width;
        cHit.h = c.hitbox.height;

        if (rectsOverlap(oHit, cHit)) return;
    }

    collectables.push(c);
    nextCollectableTimer = Math.floor(Math.random() * 0) + 20;
}



/* =====================================================
   RESTART
===================================================== */
function restartGame() {
    obstacles = [];
    collectables = [];
    floatingTexts = [];
    floatingScores = [];
    score = 0;
    gameOver = false;
    speedMultiplier = 1;
    player.y = GROUND_Y;
    player.velocityY = 0;
    player.jumpCount = 0;
    player.state = "run";
    runSound.play().catch(()=>{});
    player.isFalling = false;
    distanceRun = 0;
    distanceScore = 0;
    coinScore = 0;
    comboMultiplier = 1;
    nextComboAt = 10;
    totalCoinsCollected = 0;
    totalScore = 0;
    displayDistance = 0;
    displayCoins = 0;
    displayTotal = 0;
    scoreAnimDone = false;

}

/* =====================================================
   UPDATE
===================================================== */
let lastTickDistance = 0;
let lastTickCoins = 0;
let lastTickTotal = 0;

function animateGameOverScores() {
    const speed = 0.05; // adjust animation speed

    // Previous values
    const prevDistance = Math.floor(displayDistance);
    const prevCoins = Math.floor(displayCoins);
    const prevTotal = Math.floor(displayTotal);

    // Animate counts
    displayDistance += Math.max(1, (distanceScore - displayDistance) * speed);
    displayCoins += Math.max(1, (coinScore - displayCoins) * speed);
    displayTotal += Math.max(1, (totalScore - displayTotal) * speed);

    displayDistance = Math.min(displayDistance, distanceScore);
    displayCoins = Math.min(displayCoins, coinScore);
    displayTotal = Math.min(displayTotal, totalScore);

    // Play tick if the displayed score increased by 1
    if (Math.floor(displayDistance) > prevDistance || Math.floor(displayCoins) > prevCoins || Math.floor(displayTotal) > prevTotal) {
        scoreTickSound.currentTime = 0;
        scoreTickSound.play().catch(()=>{});
    }

    if (
        displayDistance === distanceScore &&
        displayCoins === coinScore &&
        displayTotal === totalScore
    ) {
        scoreAnimDone = true;
    }
}



function update() {
    if (!gameStarted) return;

// Allow score animation after game over
if (gameOver) {
    animateGameOverScores();
    return;
}


// PLAYER FALLING INTO HOLE
if (player.isFalling) {
    player.fallSpeed += 0.5;
    player.y += player.fallSpeed;

    // Disable normal movement
    player.isJumping = false;
if (player.y > canvas.height) {
    gameOver = true;
    runSound.pause();
    gameOverSound.play();
    totalScore = distanceScore + coinScore;
}



    return; // IMPORTANT: skip rest of update
}

    const now = performance.now();
const delta = Math.min((now - lastTime) / 16.67, 2);
lastTime = now;

speedMultiplier = Math.min(
    speedMultiplier + SPEED_INCREMENT * delta,
    MAX_SPEED_MULTIPLIER
);

    const speed = GAME_SPEED * speedMultiplier;

// DISTANCE-BASED SCORING (DISTANCE ONLY)
distanceRun += speed;
distanceScore = Math.floor(distanceRun * DISTANCE_SCORE_RATE);


backgroundX = Math.floor(backgroundX - speed);
    if (backgroundX <= -canvas.width) backgroundX = 0;

    player.velocityY += GRAVITY;
    player.y += player.velocityY;
if (!player.isFalling && player.y >= GROUND_Y) {
    player.y = GROUND_Y;
    player.velocityY = 0;
    player.jumpCount = 0;
    if (player.state !== "run") { 
        player.state = "run"; 
        runSound.play().catch(()=>{}); 
    }
}


    animationTimer++;
    if (animationTimer > 3) {
        animationTimer = 0;
        animationFrame++;
        if (player.state === "run" && animationFrame >= runFrames.length) animationFrame = 0;
        if (player.state === "jump" && animationFrame >= jumpFrames.length) animationFrame = jumpFrames.length - 1;
    }

    if (nextObstacleTimer-- <= 0) spawnObstacle();
    if (nextCollectableTimer-- <= 0) spawnCollectable();

    obstacles.forEach(o => o.x -= speed);
    collectables.forEach(c => c.x -= speed);

pHit.x = player.x + player.hitbox.offsetX;
pHit.y = player.y + player.hitbox.offsetY;
pHit.w = player.hitbox.width;
pHit.h = player.hitbox.height;


    obstacles.forEach(o => {
// HOLE LOGIC (BEFORE collision)
// HOLE LOGIC (BEFORE collision)
if (o.type === "hole" && !player.isFalling) {
    const playerLeft = player.x;
    const playerRight = player.x + player.width;
    const holeLeft = o.x;
    const holeRight = o.x + o.width;

    const onGround = player.y + player.height >= GROUND_Y - 2;
    const margin = 2; // 2px margin
    // Player falls only if fully over the hole
if (
    playerLeft + margin >= holeLeft &&
    playerRight - margin <= holeRight &&
    onGround &&
    !player.isJumping
) {
    player.isFalling = true;
    player.fallSpeed = 2;
    player.jumpCount = player.maxJumps;
}
}


// Skip collision for holes
if (o.type !== "hole") {
    const h = o.hitbox;
    const oHit = { x:o.x + h.offsetX, y:o.y + h.offsetY, w:h.width, h:h.height };
if (rectsOverlap(pHit, oHit)) {
    gameOverSound.play();
    gameOver = true;
    runSound.pause();
    totalScore = distanceScore + coinScore;
}

}
    });

    collectables = collectables.filter(c => {
        const cHit = { x:c.x + c.hitbox.offsetX, y:c.y + c.hitbox.offsetY, w:c.hitbox.width, h:c.hitbox.height };

if (rectsOverlap(pHit, cHit)) {

    // RAW COIN COUNT (FOR COMBO)
    totalCoinsCollected++;

    // COMBO-AFFECTED VALUE
    const coinValue = comboMultiplier;
    coinScore += coinValue;

    collectSound.play();


    // ===============================
    // COMBO SYSTEM (EVERY 10 CRYSTALS)
    // ===============================
if (totalCoinsCollected >= nextComboAt) {
    comboMultiplier++;

    // Center screen combo text (existing behavior)
    const ft = floatingTextPool.pop() || {};
    ft.x = canvas.width / 2;
    ft.y = canvas.height / 2 - 80;
    ft.text = "COMBO x" + comboMultiplier;
    ft.opacity = 1;
    ft.speedY = 1.2;
    ft.followPlayer = false;
    floatingTexts.push(ft);

    // Player floating combo text (NEW)
    spawnPlayerComboText("COMBO x" + comboMultiplier);

    nextComboAt += 10;
}



    const fs = floatingScorePool.pop() || {};
    fs.x = c.x + c.width / 2;
    fs.y = c.y;
    fs.value = "+" + coinValue;
    fs.opacity = 1;
    fs.speedY = 1.5 + speedMultiplier * 0.3;
    floatingScores.push(fs);

    return false;
}
        
        return c.x + c.width > 0;
    });

    // Update floating texts
floatingTexts.forEach(ft => {
    if (ft.followPlayer) {
        ft.x = player.x + player.width / 2;
        ft.y -= ft.speedY;
    } else {
        ft.y -= ft.speedY;
    }
    ft.opacity -= 0.02;
});


    floatingTexts = floatingTexts.filter(ft => {
    if (ft.opacity <= 0) {
        floatingTextPool.push(ft);
        return false;
    }
    return true;
});


    // Update floating scores
    floatingScores.forEach(fs => {
        fs.y -= fs.speedY;
        fs.opacity -= 0.02 + (speedMultiplier-1)*0.01;
    });
    floatingScores = floatingScores.filter(fs => {
    if (fs.opacity <= 0) {
        floatingScorePool.push(fs);
        return false;
    }
    return true;
});


    obstacles = obstacles.filter(o => o.x + o.width > 0);
}

/* =====================================================
   HOLE DRAWING (SPLIT FOR DEPTH)
===================================================== */


function drawHoleTop(o) {
    // Rim
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(
        o.x + o.width / 2,
        GROUND_Y + o.height * 2.15,
        o.width * 0.6,
        o.height * 0.3,
        0, 0, Math.PI * 2
    );
    ctx.fill();

    ctx.strokeStyle = "#777";
    ctx.stroke();
}

/* =====================================================
   DRAW
===================================================== */
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (!assetsReady) {
        ctx.fillStyle = "#fff";
        ctx.font = "22px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Loading...", canvas.width / 2, canvas.height / 2 - 20);

        const percent = Math.floor((assetsLoaded / totalAssets) * 100);
        ctx.font = "18px Arial";
        ctx.fillText(percent + "%", canvas.width / 2, canvas.height / 2 + 10);
        return;
    }

    if (!gameStarted) {
        ctx.fillStyle="#fff"; ctx.font="26px Arial"; ctx.textAlign="center";
        ctx.fillText("Fast Travel Running Game",canvas.width/2,canvas.height/2);
        ctx.font="18px Arial";
        ctx.fillText("Click anywhere to start",canvas.width/2,canvas.height/2+30);
        return;
    }

    safeDraw(background, backgroundX, 0, canvas.width, canvas.height);
    safeDraw(background, backgroundX + canvas.width, 0, canvas.width, canvas.height);

// ===============================
// HOLE BOTTOM (BEHIND PLAYER)
// ===============================

drawPlayerShadow(player);

if (player.isFalling) {
    ctx.save();

    // Clip player so lower body disappears into hole
    ctx.beginPath();
    ctx.rect(
        0,
        0,
        canvas.width,
        GROUND_Y + player.height * 0.55
    );
    ctx.clip();
}

const img = player.state === "run" ? runFrames[animationFrame] : jumpFrames[animationFrame];
safeDraw(img, player.x, player.y, player.width, player.height);

if (player.isFalling) {
    ctx.restore();
}

// ===============================
// HOLE TOP (COVERS PLAYER)
// ===============================
obstacles.forEach(o => {
    if (o.type === "hole") {
        drawHoleTop(o);
    }
});


obstacles.forEach(o => {
    switch(o.type) {
        case "fridge":
            // Fridge body
            ctx.fillStyle = "#d9d9d9";
            ctx.fillRect(o.x, o.y, o.width, o.height);
            ctx.strokeStyle = "#555";
            ctx.strokeRect(o.x, o.y, o.width, o.height);

            // Doors
            ctx.strokeStyle = "#bbb";
            ctx.beginPath();
            ctx.moveTo(o.x, o.y + o.height / 2);
            ctx.lineTo(o.x + o.width, o.y + o.height / 2);
            ctx.stroke();

            // Handles
            ctx.fillStyle = "#888";
            ctx.fillRect(o.x + o.width - Math.round(o.width*0.1), o.y + Math.round(o.height*0.1), Math.round(o.width*0.1), Math.round(o.height*0.1));
            ctx.fillRect(o.x + o.width - Math.round(o.width*0.1), o.y + o.height / 2 + Math.round(o.height*0.1), Math.round(o.width*0.1), Math.round(o.height*0.1));
            break;

        case "table":
            // Table top
	    ctx.fillStyle = "#b0b0b0";
            ctx.fillRect(o.x, o.y, o.width, Math.round(o.height * 0.2));
            ctx.strokeStyle = "#777";
            ctx.strokeRect(o.x, o.y, o.width, Math.round(o.height * 0.2));

            // Table legs
            const legWidth = Math.round(o.width * 0.08);
            const legHeight = Math.round(o.height * 0.8);
            const legOffsetX = Math.round(o.width * 0.05);
            const legOffsetY = Math.round(o.height * 0.2);
            ctx.fillStyle = "#999";
            ctx.fillRect(o.x + legOffsetX, o.y + legOffsetY, legWidth, legHeight);
            ctx.fillRect(o.x + o.width - legOffsetX - legWidth, o.y + legOffsetY, legWidth, legHeight);
            ctx.fillRect(o.x + o.width / 2 - legWidth / 2, o.y + legOffsetY, legWidth, legHeight);

            // Optional shading
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            ctx.fillRect(o.x, o.y + Math.round(o.height * 0.2), o.width, 2);
            break;

    case "oven":
        // Oven body
        ctx.fillStyle = "#bfbfbf"; // light grey body
        ctx.fillRect(o.x, o.y, o.width, o.height);
        ctx.strokeStyle = "#666"; // darker grey border
        ctx.strokeRect(o.x, o.y, o.width, o.height);

        // Oven door window
        const windowHeight = Math.round(o.height * 0.5);
        const windowY = o.y + Math.round(o.height * 0.3);
        ctx.fillStyle = "#888"; // medium grey glass
        ctx.fillRect(o.x + 5, windowY, o.width - 10, windowHeight);
        ctx.strokeStyle = "#555";
        ctx.strokeRect(o.x + 5, windowY, o.width - 10, windowHeight);

        // Oven handle
        const handleHeight = Math.round(o.height * 0.05);
        const handleY = windowY - handleHeight - 2;
        ctx.fillStyle = "#999"; // grey handle
        ctx.fillRect(o.x + 5, handleY, o.width - 10, handleHeight);

        // Bottom vent detail
        const ventHeight = Math.round(o.height * 0.05);
        ctx.fillStyle = "#777"; // darker grey
        ctx.fillRect(o.x + 5, o.y + o.height - ventHeight - 2, o.width - 10, ventHeight);
            break;



case "shelf":
    // Shelf body (top rectangle)
    ctx.fillStyle = "#bfbfbf"; // light grey
    const shelfHeight = Math.round(o.height * 0.15);
    ctx.fillRect(o.x, o.y, o.width, shelfHeight);
    ctx.strokeStyle = "#777"; // border
    ctx.strokeRect(o.x, o.y, o.width, shelfHeight);

    // Hanging pans
    const panSizes = [0.15, 0.2, 0.12]; // relative to shelf width
    const panYOffset = shelfHeight + 5; // distance below shelf
    panSizes.forEach((sizeFactor, index) => {
        const panDiameter = Math.round(o.width * sizeFactor);
        const panX = o.x + Math.round((o.width / 4) * (index + 0.5) - panDiameter / 2);
        const panY = o.y + panYOffset;

        // Draw round pan
        ctx.fillStyle = "#999"; // medium grey
        ctx.beginPath();
        ctx.arc(panX + panDiameter/2, panY + panDiameter/2, panDiameter/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#555"; // border
        ctx.stroke();

        // Draw straight handle (rectangle hanging from shelf)
        const handleWidth = Math.round(panDiameter * 0.1);
        const handleHeight = panY - o.y; // distance from shelf to pan top
        ctx.fillStyle = "#777"; // handle color
        ctx.fillRect(panX + panDiameter/2 - handleWidth/2, o.y + shelfHeight, handleWidth, handleHeight);
    });
    break;
    }
});



    collectables.forEach(c => safeDraw(c.image, c.x, c.y, c.width, c.height));


    // Draw floating texts
    floatingTexts.forEach(ft => {
        ctx.globalAlpha = ft.opacity;
        if (speedMultiplier < 1.5) ctx.fillStyle = "#fff";
        else if (speedMultiplier < 2.5) ctx.fillStyle = "#edf507";
        else ctx.fillStyle = "#f52b07";
        ctx.font = `${10 + speedMultiplier * 3}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText(ft.text, ft.x, ft.y);
        ctx.globalAlpha = 1;
    });

    // Draw floating scores
    floatingScores.forEach(fs => {
        ctx.globalAlpha = fs.opacity;
        ctx.fillStyle = "#ffffff";
        ctx.font = `${18 + speedMultiplier*2}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText(fs.value, fs.x, fs.y);
        ctx.globalAlpha = 1;
    });

ctx.fillStyle = "#fff";
ctx.font = "18px Arial";
ctx.textAlign = "left";
ctx.fillText("Distance: " + distanceScore, 10, 30);

ctx.textAlign = "center";
ctx.fillStyle = "#ffd700";
ctx.font = "16px Arial";
ctx.fillText("Combo x" + comboMultiplier, canvas.width / 2, 30);

const coinIconSize = 18;
const padding = 10;

ctx.textAlign = "right";
ctx.fillText(
    coinScore,
    canvas.width - padding - coinIconSize - 4,
    30
);

// Draw coin icon
ctx.drawImage(
    collectableImg,
    canvas.width - padding - coinIconSize,
    14,
    coinIconSize,
    coinIconSize
);


if (gameOver) {
    ctx.textAlign = "center";

    ctx.fillStyle = "#fff";
    ctx.font = "28px Arial";
    ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 40);

    ctx.font = "18px Arial";
ctx.fillText(
    "Distance: " + Math.floor(displayDistance),
    canvas.width / 2,
    canvas.height / 2
);

ctx.fillText(
    "Crystals: " + Math.floor(displayCoins),
    canvas.width / 2,
    canvas.height / 2 + 25
);

ctx.fillStyle = "#ffd700";
ctx.font = "22px Arial";
ctx.fillText(
    "TOTAL SCORE: " + Math.floor(displayTotal),
    canvas.width / 2,
    canvas.height / 2 + 65
);

    ctx.font = "14px Arial";
    ctx.fillStyle = "#aaa";
    ctx.fillText(
        "Tap or press Space to restart",
        canvas.width / 2,
        canvas.height / 2 + 95
    );
}


    if (DEBUG_HITBOX) {
        drawHitbox(player.x + player.hitbox.offsetX, player.y + player.hitbox.offsetY, player.hitbox.width, player.hitbox.height, "lime");
        obstacles.forEach(o => { const h=o.hitbox; drawHitbox(o.x+h.offsetX,o.y+h.offsetY,h.width,h.height,"red"); });
        collectables.forEach(c => { drawHitbox(c.x+c.hitbox.offsetX,c.y+c.hitbox.offsetY,c.hitbox.width,c.hitbox.height,"yellow"); });
    }
}

/* =====================================================
   LOOP
===================================================== */
function loop(now) {
    let deltaTime = now - lastFrameTime;
    if (deltaTime > MAX_DELTA) deltaTime = MAX_DELTA; // cap delta

    frameAccumulator += deltaTime;
    lastFrameTime = now;

    while (frameAccumulator >= FRAME_TIME) {
        update();
        frameAccumulator -= FRAME_TIME;
    }

    draw();
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);



</script>
</body>
</html>


